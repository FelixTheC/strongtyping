from _typeshed import Incomplete
from strongtyping._utils import action as action, remove_subclass as remove_subclass
from strongtyping.cached_set import CachedSet as CachedSet
from strongtyping.config import SEVERITY_LEVEL as SEVERITY_LEVEL
from strongtyping.strong_typing_utils import TypeMisMatch as TypeMisMatch, check_type as check_type, checking_typing_typedict_values as checking_typing_typedict_values, default_return_queue as default_return_queue
from typing import Any, Callable, Optional, Type, TypeVar

P: Incomplete
FuncT = TypeVar('FuncT', bound=Callable[..., Any])
T = TypeVar('T')
CACHE_IGNORE_CLASS_FUNCTIONS: Incomplete

def match_typing(_func=..., *, excep_raise: dict[Any, Any] | type[TypeMisMatch] = ..., subclass: bool = ..., severity: str = ..., **kwargs) -> FuncT | Any: ...
def add_required_methods_to_class(cls, inst) -> None: ...

class MatchTypedDict:
    def __new__(cls, instance: Incomplete | None = ..., *args, **kwargs) -> MatchTypedDict: ...
    excep_raise: Incomplete
    cache_size: Incomplete
    severity: Incomplete
    cls: Incomplete
    def __init__(self, cls: Incomplete | None = ..., *args, **kwargs) -> None: ...
    def __getattr__(self, item): ...
    @property
    def is_typed_dict(self) -> Optional[bool]: ...
    def __match_class_repr__(self) -> str: ...
    def create_error_msg(self, args: dict) -> str: ...
    def check_annotations(self) -> bool: ...
    def __call__(self, *args, **kwargs) -> Type[T]: ...

def match_class_typing(cls: Incomplete | None = ..., **kwargs: dict) -> Incomplete: ...
def getter(func) -> Any: ...
def setter(func) -> Any: ...
def getter_setter(func) -> Any: ...

class FinalClass:
    def __new__(cls, instance: Incomplete | None = ..., *args, **kwargs) -> FinalClass: ...
    cls: Incomplete
    def __init__(self, cls: Incomplete | None = ..., *args, **kwargs) -> None: ...
    def __getattr__(self, item: Any) -> Any: ...
    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...
    @property
    def __doc__(self) -> str: ...
