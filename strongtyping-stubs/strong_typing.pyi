from _typeshed import Incomplete
from strongtyping._utils import action as action, remove_subclass as remove_subclass
from strongtyping.cached_set import CachedSet as CachedSet
from strongtyping.config import SEVERITY_LEVEL as SEVERITY_LEVEL
from strongtyping.strong_typing_utils import TypeMisMatch as TypeMisMatch, check_type as check_type, checking_typing_typedict_values as checking_typing_typedict_values, default_return_queue as default_return_queue
from typing import Type

CACHE_IGNORE_CLASS_FUNCTIONS: Incomplete

def match_typing(_func: Incomplete | None = ..., *, excep_raise: Type[Exception] = ..., subclass: bool = ..., severity: str = ..., **kwargs): ...
def add_required_methods_to_class(cls, inst) -> None: ...

class MatchTypedDict:
    def __new__(cls, instance: Incomplete | None = ..., *args, **kwargs): ...
    excep_raise: Incomplete
    cache_size: Incomplete
    severity: Incomplete
    cls: Incomplete
    def __init__(self, cls: Incomplete | None = ..., *args, **kwargs) -> None: ...
    def __getattr__(self, item): ...
    @property
    def is_typed_dict(self): ...
    def __match_class_repr__(self): ...
    def create_error_msg(self, args: dict): ...
    def check_annotations(self): ...
    def __call__(self, *args, **kwargs): ...

def match_class_typing(cls: Incomplete | None = ..., **kwargs): ...
def getter(func): ...
def setter(func): ...
def getter_setter(func): ...

class FinalClass:
    def __new__(cls, instance: Incomplete | None = ..., *args, **kwargs): ...
    cls: Incomplete
    def __init__(self, cls: Incomplete | None = ..., *args, **kwargs) -> None: ...
    def __getattr__(self, item): ...
    def __call__(self, *args, **kwargs): ...
    @property
    def __doc__(self): ...
